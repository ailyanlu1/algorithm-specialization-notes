WEBVTT

1
00:00:00.012 --> 00:00:03.350
So in this video and the next, we're going
to study a very cool divide and conquer

2
00:00:03.362 --> 00:00:06.835
algorithm for the closest pair problem.
this is a problem where you're given n

3
00:00:06.847 --> 00:00:10.230
points in the plane and you want to figure
out which pair of points are closest to

4
00:00:10.242 --> 00:00:13.240
each other. So this would be the first
taste we get of an application in

5
00:00:13.252 --> 00:00:17.229
computational geometry, which is the part
of algorithms which studies how to reason

6
00:00:17.241 --> 00:00:21.251
and manipulate geometric objects. So those
algorithms are important in, among other

7
00:00:21.263 --> 00:00:25.424
areas robotics, computer vision and
computer graphics. So this is relatively

8
00:00:25.436 --> 00:00:29.013
advanced material, it's a bit more
difficult than the other applications of

9
00:00:29.025 --> 00:00:32.881
divide and conquer that we've seen. The
algorithm's a little bit tricky and it has

10
00:00:32.893 --> 00:00:36.596
a quite nontrivial proof of correctness,
so just be ready for that and also be

11
00:00:36.608 --> 00:00:41.073
warned that because it's more advanced I'm
going to talk about the material in at a

12
00:00:41.085 --> 00:00:44.797
slightly faster pace tha I do in most of
the other videos. So let's begin now by

13
00:00:44.809 --> 00:00:48.279
defining the problem formally, so we're
given as imput endpoints in the plane, so

14
00:00:48.291 --> 00:00:51.811
each one just define by its x coordinate
and ist y coordinate. And when we talk

15
00:00:51.823 --> 00:00:54.988
about the distance between two points in
this problem, we're going to focus on

16
00:00:55.000 --> 00:00:58.378
Euclidean distance. So, let me remind you
what that is briefly, but we're going to

17
00:00:58.390 --> 00:01:01.651
introduce some simple notation for that,
which we'll use for the rest of the

18
00:01:01.663 --> 00:01:05.532
lecture. So we're just going to note the
Euclidean distance between two points, pi

19
00:01:05.544 --> 00:01:09.368
and pj, by d of pi pj. So in terms of the
x and y coordinates of these two points,

20
00:01:09.458 --> 00:01:13.528
we just look at the squared differences in
each coordinate, sum them up, and take the

21
00:01:13.540 --> 00:01:17.342
square root. And now as the name of the
problem would suggest, the goal is to

22
00:01:17.354 --> 00:01:20.900
identify among all pairs of points that
pair which has the smallest distance

23
00:01:20.900 --> 00:01:23.860
between them.
Next, let's start getting a feel for the

24
00:01:23.872 --> 00:01:27.479
problem by making some preliminary
observations. First, I want to make an

25
00:01:27.491 --> 00:01:31.497
assumption purely for convenience that
there's no ties. So that is I'm going to

26
00:01:31.509 --> 00:01:35.436
assume all endpoints have distinct x
coordinat es, and also all endpoints have

27
00:01:35.448 --> 00:01:38.909
distinct y coordinates.
It's not difficult to extend the algorithm

28
00:01:38.921 --> 00:01:42.648
to accommodate ties. I'll leave it to you
to think about how to do that. So next,

29
00:01:42.660 --> 00:01:46.364
let's draw some parallels with the problem
of counting inversions, which was a

30
00:01:46.376 --> 00:01:50.029
earlier application of divide and conquer
that we saw. The first parallel I want,

31
00:01:50.168 --> 00:01:54.280
want to out is that, if we're comfortable
with the quadratic time algorithm, then

32
00:01:54.292 --> 00:01:57.930
this is not a hard problem, we can simply
solve this by brute-force search. And

33
00:01:57.942 --> 00:02:01.355
again, by brute-force search, I just mean
we set up a double for loop, which

34
00:02:01.367 --> 00:02:04.955
iterates over all distinct pairs of
points. We compute the distance for each

35
00:02:04.967 --> 00:02:08.880
such pair and we remember the smallest.
That's clearly a correct algorithm, it has

36
00:02:08.892 --> 00:02:12.964
to iterate over a quadratic number of
pairs, so its running time is going to be

37
00:02:13.191 --> 00:02:17.314
theta of n squared. And, as always, the
question is can we apply some algorithmic

38
00:02:17.326 --> 00:02:21.344
ingenuity to do better? Can we have a
better algorithm than this naive one which

39
00:02:21.356 --> 00:02:25.264
iterates over all pairs of points? You
might have a, an initial instinct that

40
00:02:25.276 --> 00:02:29.167
because the problem asks about a quadratic
number of different objects, perhaps we

41
00:02:29.179 --> 00:02:32.589
fundamentally need to do quadratic work.
But again, recall back in counting

42
00:02:32.601 --> 00:02:36.278
inversions, using divide and conquer, we
were able to get an n log n algorithm

43
00:02:36.363 --> 00:02:40.316
despite the fact that there might be as
many as a quadratic number of inversions

44
00:02:40.328 --> 00:02:44.330
in an array. So the question is, can we do
something similar here for the closest

45
00:02:44.342 --> 00:02:47.941
pair problem? Now, one of the keys to
getting an n log n time algorithm for

46
00:02:47.953 --> 00:02:51.722
counting inversions was to leverage a
sorting subroutine. Recall that we

47
00:02:51.734 --> 00:02:55.790
piggybacked on merge sort to count the
number of inversions in n log n time. So

48
00:02:55.802 --> 00:02:59.874
the question is, here, with the closest
pair problem, perhaps, sorting again can

49
00:02:59.886 --> 00:03:03.342
be useful in some way to beat the
quadratic barrier. So, to develop some

50
00:03:03.354 --> 00:03:07.278
evidence that sorting will indeed help us
compute the closest pair of points

51
00:03:07.290 --> 00:03:11.239
embedded in quadratic time, let's look at
a special case of the problem, really, an

52
00:03:11.251 --> 00:03:15.123
easier version of t he problem, which is
when the points are just in one dimension,

53
00:03:15.212 --> 00:03:18.654
so on the line rather that in two
dimensions in the plane. So in the 1D

54
00:03:18.666 --> 00:03:23.277
version, all the points just lie on a line
like this one, and we're given the points

55
00:03:23.289 --> 00:03:27.753
in some arbitrary order not necessarily in
sorted order. So, a way to solve the

56
00:03:27.765 --> 00:03:32.204
closest pair problem in one dimension, is
to simply sort the points, and then of

57
00:03:32.216 --> 00:03:36.300
course, the closest pair better be
adjacent in this ordering, so you just

58
00:03:36.312 --> 00:03:40.665
iterate through the n minus 1 consecutive
pairs and see which one is closest to each

59
00:03:40.677 --> 00:03:44.385
other So, more formally, here's how you
solve the one-dimensional version of the

60
00:03:44.397 --> 00:03:47.785
problem. You sort the points according to
their only coordinate, because you're

61
00:03:47.797 --> 00:03:51.510
going to remember, this is one dimension.
So as we've seen, using merge sort, we can

62
00:03:51.522 --> 00:03:55.335
sort the points in n log n time and then
we just do a scan through the points, so

63
00:03:55.347 --> 00:03:58.685
this takes linear time. And for each
consecutive pair, we compute their

64
00:03:58.697 --> 00:04:02.310
distance and we remember the smallest of
those consecutive pairs and we return

65
00:04:02.322 --> 00:04:06.078
that. That's gotta be the closest pair.
So, in this picture here on the right, I'm

66
00:04:06.090 --> 00:04:09.334
just going to circle here in green the
closest pair of points. So this is

67
00:04:09.346 --> 00:04:12.862
something we discover by sorting and then
doing a linear scan. Now, needless to say,

68
00:04:12.945 --> 00:04:16.440
this isn't directly useful, this is not
the problem I started out with. We wanted

69
00:04:16.452 --> 00:04:19.600
to find out the closest pair among of
points in the plane not points in the

70
00:04:19.612 --> 00:04:23.044
line. But, I want to point out that, this,
even in the line, there are a quadratic

71
00:04:23.056 --> 00:04:26.915
number of different pairs, so brute-force
search is still a quadratic time algorythm

72
00:04:27.422 --> 00:04:31.690
even in the 1D case. So at least, with one
dimension, we can use sorting, piggyback

73
00:04:31.702 --> 00:04:35.704
on it, to beat the naive brute-force
search bound and solve the problem in n

74
00:04:35.716 --> 00:04:39.635
log n time. So our goal for this lecture
is going to be to devise an equally good

75
00:04:39.647 --> 00:04:43.761
algorithm for the two-dimensional case, so
we want to solve closest pair of points in

76
00:04:43.773 --> 00:04:47.558
the plane, again, in n log n, n time.
So we will succeed in this goal. I'm going

77
00:04:47.558 --> 00:04:51.136
to show you an n log n time algo rithm for
2D closest pair. It's going to take us a

78
00:04:51.148 --> 00:04:54.779
couple steps. So let me begin with a high
level approach. Alright. So the first I

79
00:04:54.791 --> 00:04:58.374
need to try is just to copy what worked
for us in the one-dimensional case. So the

80
00:04:58.555 --> 00:05:02.134
one-dimensional case, we first sorted the
points by their coordinate and that was

81
00:05:02.146 --> 00:05:06.017
really useful. Now, in the 2D case, points
have two coordinates, x coordinates and y

82
00:05:06.029 --> 00:05:09.610
coordinates, so there's two ways to sort
them. So let's just sort them both ways,

83
00:05:10.102 --> 00:05:13.612
that is, the first step of our algorithm,
which you should really think of as a

84
00:05:13.624 --> 00:05:17.082
preprocessing step. We're going to take
the input points. We invoke merge sort

85
00:05:17.094 --> 00:05:20.385
once to sort them according to x
coordinate, that's one copy of the points.

86
00:05:20.470 --> 00:05:24.039
And then we make a second copy of the
points where they're sorted by y

87
00:05:24.051 --> 00:05:27.754
coordinates. So we're going to call those
copies of points px, that's an array of

88
00:05:27.766 --> 00:05:31.646
the points sorted by x coordinate, and py
for them sorted by y coordinate. Now, we

89
00:05:31.658 --> 00:05:35.513
know merge short takes n log n times, so
this preprocessing step only takes o of n

90
00:05:35.525 --> 00:05:39.228
log n time. And again, given that we're
shooting for an algorithm with running

91
00:05:39.240 --> 00:05:42.953
time big O of n log n, why not sort the
points? We don't even know how we're going

92
00:05:42.953 --> 00:05:46.660
to use this fact right now, but it's sort
of harmless. It's not going to effect our

93
00:05:46.672 --> 00:05:50.610
goal of getting a big of O n log n time
algorithm. And indeed, this illustrates a

94
00:05:50.622 --> 00:05:54.410
broader point, which is one of the themes
of this course. So recall, I hope one of

95
00:05:54.422 --> 00:05:57.985
the things you take away from this course
is a sense for what are the four free

96
00:05:57.997 --> 00:06:01.771
primitives, what are manipulations or
operations you can do on data which

97
00:06:01.783 --> 00:06:05.273
basically are costless. Meaning that if
your data set fits in the main memory of

98
00:06:05.285 --> 00:06:08.750
your computer, you can basically invoke
the primitive and it's just going to run

99
00:06:08.762 --> 00:06:12.139
blazingly fast, and you can just do it
even if you don't know why. And again,

100
00:06:12.223 --> 00:06:15.450
sorting is the canonical for free
primitive, although, we'll see some more

101
00:06:15.462 --> 00:06:18.953
later in the course and so, here, we're
using exactly that principle.

102
00:06:18.962 --> 00:06:22.689
So we don't even understand why yet we
might wa nt the points to be sorted. It

103
00:06:22.701 --> 00:06:27.066
just seems like it's probably going to be
useful, motivated by the 1D case, so let's

104
00:06:27.078 --> 00:06:31.085
go ahead and make assorted copies of the
points by x and y coordinate upfront. So

105
00:06:31.097 --> 00:06:35.438
reasoning by analogy with the 1D suggests
that sorting the points might be useful,

106
00:06:35.526 --> 00:06:39.228
but we can't carry this analogy too far.
So in particular, we're not going to be

107
00:06:39.240 --> 00:06:43.147
able to get away with just a simple linear
scan through these arrays to identify the

108
00:06:43.159 --> 00:06:47.156
closest pair of points. So, to see that,
consider the following example.

109
00:06:47.168 --> 00:06:51.424
So we're going to look at a point set
which has six points. There's going to be

110
00:06:51.436 --> 00:06:56.120
two points, which I'll put in blue which
are very close in x coordinate, but very

111
00:06:56.132 --> 00:07:00.829
far away in y coordinate. And then there's
going to be another pair of points which

112
00:07:00.841 --> 00:07:05.210
I'll do in green, which are very close in
y coordinate, but very far away in x

113
00:07:05.222 --> 00:07:09.463
coordinate. And then there's going to be a
red pair of points, which are not too far

114
00:07:09.475 --> 00:07:13.423
away in either the x coordinate or the y
coordinate. So in this set of six points,

115
00:07:13.514 --> 00:07:17.142
the closest pair is the pair of red
points. They're not even going to show up

116
00:07:17.154 --> 00:07:21.027
consecutively on either of the two arrays,
right? So in the array that's sorted by x

117
00:07:21.039 --> 00:07:24.829
coordinate, this blue point here is going
to be wedged in between the two red

118
00:07:24.841 --> 00:07:28.893
points, they won't be consecutive. And
similarly in the, in py, which is sort of

119
00:07:28.905 --> 00:07:32.724
by y coordinate, this green coordinate is
going to be wedged between the two red

120
00:07:32.736 --> 00:07:37.026
points. So you won't even notice these red
point if you just do a linear scan if your

121
00:07:37.038 --> 00:07:40.238
px and py, or py look at the consecutive
pairs of points. So, following our

122
00:07:40.250 --> 00:07:44.323
preprocessing step where we just invert,
invoke merge sort twice we're going to do

123
00:07:44.335 --> 00:07:48.289
a quite nontrivial divide and conquer
algorithm to compute the closest pair. So

124
00:07:48.301 --> 00:07:52.227
really, in this algorithm, we're applying
the divide and conquer algorithm twice.

125
00:07:52.316 --> 00:07:56.111
First, internal to the sorting subroutine,
assuming that we use the merge sort

126
00:07:56.123 --> 00:08:00.045
algorithm to sort. Divide and conquer is
being used there to get an n log n running

127
00:08:00.057 --> 00:08:04.058
time in this preprocessing step, and the
n, we're going to use it again on sorted

128
00:08:04.070 --> 00:08:07.760
arrays in a new way and that's what I'm
going to tell you about next. So let's

129
00:08:07.772 --> 00:08:11.685
just briefly review the divide and conquer
algorithm design paradigm before we apply

130
00:08:11.697 --> 00:08:15.335
it to the closest pair problem. So, as
usual, the first step is to figure out a

131
00:08:15.347 --> 00:08:18.760
way to divide your problem into smaller
subproblems. Sometimes this has a

132
00:08:18.772 --> 00:08:22.375
reasonable amount of ingenuity, but it's
not going to. Here in the closest pair

133
00:08:22.387 --> 00:08:25.438
problem, we're going to proceed exactly as
we did in the merge sort and counting

134
00:08:25.450 --> 00:08:28.652
inversions problems, where we took the
array and broke it into its left and right

135
00:08:28.664 --> 00:08:31.748
half. So here, we're going to take the
input point set, and again, just recurse

136
00:08:31.760 --> 00:08:34.693
on the left half of the points, and
recurse on the right half of the points.

137
00:08:34.772 --> 00:08:37.936
So here, by left and right, I mean with
respect to the points x coordinates.

138
00:08:38.017 --> 00:08:41.529
There's pretty much never any ingenuity in
the conquer step, that just means you take

139
00:08:41.541 --> 00:08:44.406
the sub-problems you identified in the
first step, and you solve them

140
00:08:44.418 --> 00:08:47.723
recursively. That's what we'll do here,
we'll recursively complete the closest

141
00:08:47.735 --> 00:08:51.058
pair in the left half of the points, and
the closest pair in the right half of the

142
00:08:51.070 --> 00:08:54.517
points. So where all the creativity in
divide and conquer algorithms is in the

143
00:08:54.529 --> 00:08:58.208
combined step. Given the solutions to your
sub problems, how do you somehow recover a

144
00:08:58.220 --> 00:09:01.598
solution to the original problem? The one
that you actually care about. So for

145
00:09:01.819 --> 00:09:05.310
closest pair, the questionis going to be,
given that you've computed the closest

146
00:09:05.322 --> 00:09:08.775
pair on the left half of the points, and
the closest pair on the right half of the

147
00:09:08.787 --> 00:09:12.383
points, how do you then quickly recover
the closest pair for the whole point set?

148
00:09:12.392 --> 00:09:15.800
That's a tricky problem, that's what we're
going to spend most of our time on. So

149
00:09:15.812 --> 00:09:18.870
let's make this divide and conquer
approach for closest pair a little bit

150
00:09:18.882 --> 00:09:22.325
more precise, so let's now actually start
spelling out our closest pair algorithm.

151
00:09:22.407 --> 00:09:26.240
The input we're given, it's, this follows
the preprocessing steps or recall that we

152
00:09:26.252 --> 00:09:30.626
invoke, merge sort, we get our two sorted
copies of the poin t set Px, sorted by x

153
00:09:30.638 --> 00:09:34.778
coordinate, and py sorted by y coordinate.
So the first dividend is the division

154
00:09:34.790 --> 00:09:38.837
step. So given that we have a copy of the
points px sorted by x coordinate, it's

155
00:09:38.849 --> 00:09:42.952
easy to identify the leftmost half of the
points, those with the, those n over two

156
00:09:43.318 --> 00:09:47.244
smallest x coordinates and in the right
half, those were the n over two largest x

157
00:09:47.256 --> 00:09:51.232
coordinates. We're going to call those Q
and R respectively. One thing I'm skipping

158
00:09:51.244 --> 00:09:54.829
over is the base case. I'm not going to
bother writing that down, so base case

159
00:09:54.841 --> 00:09:58.659
omitted, but it's what you would think it
would be. So basically once you have a

160
00:09:58.671 --> 00:10:02.374
small number point, say two points or
three points, then you can just solve the

161
00:10:02.386 --> 00:10:06.368
problem in constant time by a brute-force
search. You just look at all the pairs and

162
00:10:06.380 --> 00:10:09.955
you return the closest pair. So think of
it being at least four points in the

163
00:10:09.967 --> 00:10:13.567
input. Now, in order to recurse, to call
clo pair again, in the left and right

164
00:10:13.579 --> 00:10:17.408
halves, we need sorted version of Q and R,
both by x coordinate and by y coordinate,

165
00:10:17.496 --> 00:10:21.301
so we're just going to form those by doing
suitable linear scans through px and py.

166
00:10:21.702 --> 00:10:26.202
And so one thing I encourage you to think
through carefully or maybe even code up

167
00:10:26.447 --> 00:10:31.366
after the video is how would you form Qx,
Qy, Rx and Ry given that you already have

168
00:10:31.378 --> 00:10:35.843
Px and Py. And if you think about it,
because Px and Py are already sorted just

169
00:10:35.855 --> 00:10:39.392
producing these sorted sublists takes
linear time. It's in some sense the

170
00:10:39.404 --> 00:10:43.380
opposite of the merge subroutine used in
merge sort. Here, we're sort of splitting

171
00:10:43.392 --> 00:10:47.341
rather than merging. But again, this can
be done in linear time, that's something

172
00:10:47.353 --> 00:10:51.329
you should think through carefully later.
So that's the division step, now we just

173
00:10:51.341 --> 00:10:54.489
conquer, meaning we recursively call
closest pair line on each of the two

174
00:10:54.501 --> 00:10:59.275
subproblems, so when we invoke closest
pair on the left half of the points on Q

175
00:10:59.662 --> 00:11:05.175
we're going to get back what are indeed,
the closest pair of points amongst those

176
00:11:05.187 --> 00:11:10.475
in Q. So we're going to call those P1 and
Pq, So among all pairs of points that both

177
00:11:10.487 --> 00:11:15.775
lie in Q, P1 and Q1 minimize the distance
between them. Similarly, we're going to

178
00:11:15.787 --> 00:11:20.739
call Q2Q2 the results of the second
recursive call, that is, P2 and Q2 are

179
00:11:20.751 --> 00:11:25.628
amongst all pairs of points that both lie
in R, the pair that has the minimum

180
00:11:25.640 --> 00:11:30.755
Euclidean distance. Now, conceptually,
there's two cases. There's a lucky case

181
00:11:30.864 --> 00:11:35.935
and there's an unlucky case. In the
original point set P, if we're lucky, the

182
00:11:35.947 --> 00:11:41.081
closest pair of points in all of P,
actually, both of them lie in Q or both of

183
00:11:41.093 --> 00:11:45.797
them lie in R. In this lucky case, we'd
already be done if the closest pair in the

184
00:11:45.809 --> 00:11:50.314
entire point set they happen to both lie
in Q, then this first recursive call is

185
00:11:50.326 --> 00:11:55.260
going to recover them and we just have
them in our hands P1Q1. Similarly, if both

186
00:11:55.272 --> 00:12:00.502
of the closest pair of points in all of P
lies on the right side in R, then they get

187
00:12:00.514 --> 00:12:05.525
handed to us on a silver platter by the
second recursive call that just operate on

188
00:12:05.537 --> 00:12:10.594
R. So in the unlucky case, the closest
pair of point in P happens to be split.

189
00:12:10.705 --> 00:12:15.880
That is, one of the points lies in the
left half, in Q, and the other point lies

190
00:12:15.892 --> 00:12:20.672
in the right half, in R. Notice, if the
closest pair of points in all of P is

191
00:12:20.684 --> 00:12:25.285
split, is half in Q and half in R, neither
recursive call is going to find it. Okay?

192
00:12:25.381 --> 00:12:29.713
The pair of points is not passed to either
of the two recursive calls, so there's no

193
00:12:29.725 --> 00:12:34.116
way it's going to be returned to us. Okay?
So we have not identified the closest pair

194
00:12:34.128 --> 00:12:38.114
after these two recursive calls, if the
closest pair happens to be split.

195
00:12:38.114 --> 00:12:41.648
This is exactly analagous to what happened
when we were counting inversions. The

196
00:12:41.660 --> 00:12:45.031
recursive call on the left half of the
array counted the left inversions. The

197
00:12:45.043 --> 00:12:48.627
recursive call on the right half of the
array counted the right inversions. But we

198
00:12:48.639 --> 00:12:52.082
still had to count the split inversions,
so in this closest pair algorithm, we

199
00:12:52.094 --> 00:12:55.509
still need a special purpose subroutine
that computes the closest pair for the

200
00:12:55.521 --> 00:12:59.110
case in which it is split, in which there
is one point in Q and one point in R. So

201
00:12:59.122 --> 00:13:02.572
just like in counting inversions, I'm
going to write down that subroutine and

202
00:13:02.584 --> 00:13:06.132
I'm going to leave it unimplemented for
now, we'll figur e out how to implement it

203
00:13:06.341 --> 00:13:10.310
quickly in the rest of the lecture. Now,
if we have a correct implementation of

204
00:13:10.322 --> 00:13:14.811
closest split pair, so that takes us input
the original point set sort of the x and y

205
00:13:14.823 --> 00:13:19.100
coordinate, and returns the smallest pair
that's split or one points in Q and one

206
00:13:19.112 --> 00:13:23.464
points in R, then we're done. So then, the
split, then the closest pair has to either

207
00:13:23.476 --> 00:13:27.180
be on the lef or onm the right or it has
to be split. Steps two through four

208
00:13:27.192 --> 00:13:31.430
compute the closest pair in each of those
categories, so those are the only possible

209
00:13:31.442 --> 00:13:35.540
candidates for the closest pair and we
just returned the best of them. So that's

210
00:13:35.552 --> 00:13:39.578
an argument for y, if we have a correct
implementation of the closest split para

211
00:13:39.578 --> 00:13:43.915
subroutine, then that implies a correct
implementation of closest pair. Now, what

212
00:13:43.927 --> 00:13:47.785
about the running time? So the running
time of the closest para algorithm is

213
00:13:47.797 --> 00:13:52.901
going to be in part determined by the
running time of closest split pair. So in

214
00:13:52.913 --> 00:13:58.013
the next quiz, I want you to think about
what kind of running time we should be

215
00:13:58.025 --> 00:14:03.173
shooting for with a closest split pair
subroutine. So the correct response of

216
00:14:03.185 --> 00:14:07.435
this quiz is the second one, and the
reasoning is just by analogy with our

217
00:14:07.447 --> 00:14:11.285
previous algorithms for merge sort and for
counting inversions. So, what is all of

218
00:14:11.297 --> 00:14:14.985
the work that we would do in this
algorithm or we do have this preprocessing

219
00:14:14.997 --> 00:14:18.485
step we call merge sort twice, we know
that's n log n, so we're not going to have

220
00:14:18.497 --> 00:14:22.035
a running time better than n log n cause
we sort at the beginning. And then, we

221
00:14:22.047 --> 00:14:25.610
have a recursive algorithm with the
following flavor, it makes two recursive

222
00:14:25.610 --> 00:14:28.393
calls.
Each recursive call is on a problem of

223
00:14:28.405 --> 00:14:32.771
exactly half the size with half the points
of the original one. And outside of the

224
00:14:32.783 --> 00:14:36.947
recursive calls, by assumption, by, in the
problem, we do a linear amount of work in

225
00:14:36.959 --> 00:14:41.250
computing the closest split pair. So we,
the exact same recursion tree which proves

226
00:14:41.262 --> 00:14:45.226
an n log n bound for merge sort, proves an
n log n bound for how much work we do

227
00:14:45.238 --> 00:14:48.967
after the preprocessing step, so that
gives us an overall running time bound of

228
00:14:48.979 --> 00:14:52.731
n log n. Remem ber, that's what we were
shooting for. We were working n log n

229
00:14:52.743 --> 00:14:56.268
already to solve the one-dimensional
version of closest pair and the goal of

230
00:14:56.280 --> 00:14:59.916
these lectures is to have an n log n
algorithm for the 2D versions. So this

231
00:14:59.928 --> 00:15:04.209
would be great. So in other words, the
goal should be to have a correct linear

232
00:15:04.221 --> 00:15:08.879
time implementation of the closest split
pair subroutine. If we can do that, we're

233
00:15:09.160 --> 00:15:12.989
home-free, we get the desired n log
algorithm. Now, I'm going to proceed in a

234
00:15:13.001 --> 00:15:17.379
little bit to show you how to implement
closest split pair, but before I do that,

235
00:15:17.477 --> 00:15:21.608
I want to point out one subtle, the key
idea, which is going to allow us to get

236
00:15:21.620 --> 00:15:26.336
this linear time correct implementation.
So, let me just put that on the slide. So,

237
00:15:26.435 --> 00:15:30.865
the key idea is that we don't actually
need a full-blown correct implementation

238
00:15:30.877 --> 00:15:35.258
of the closets split pair subroutine. So,
I'm not actually going to show you a

239
00:15:35.270 --> 00:15:39.625
linear time subroutine that always
correctly computes the closets split pair

240
00:15:39.637 --> 00:15:44.502
of a point set. The reason I'm going to do
that is that's actually a strictly harder

241
00:15:44.514 --> 00:15:49.018
problem than what we need to have a
correct recursive algorithm. We do not

242
00:15:49.030 --> 00:15:54.259
actually need a subroutine that, for every
point sets, always correctly computes the

243
00:15:54.271 --> 00:15:58.855
closest split pair of points. Remember,
there's a lucky case and there's an

244
00:15:58.867 --> 00:16:03.568
unlucky case. The lucky case is where the
closest pair in the whole point set P

245
00:16:03.580 --> 00:16:08.192
happens to lie entirely in the left half
of the points Q or in the right half of

246
00:16:08.204 --> 00:16:12.797
the points R In that lucky case, we, one
of our recursive calls will identify this

247
00:16:12.809 --> 00:16:17.082
closest pair and hand it over to us on a
silver platter. We could care less about

248
00:16:17.094 --> 00:16:21.435
the split pairs in that case. We get the
right answer without even looking at the

249
00:16:21.447 --> 00:16:25.427
split pair, pairs. Now, there's this
unlucky case where the split pairs happens

250
00:16:25.439 --> 00:16:29.805
to be the closest pair of points. That is
when we need this linear time subroutine,

251
00:16:29.901 --> 00:16:34.414
and only. then, only in the unlucky case
where the closest pair of points happens

252
00:16:34.426 --> 00:16:38.753
to be split. Now, that's in some sense, a
fairly trivial observation, but, there's a

253
00:16:38.765 --> 00:16:42.986
lot of ingenuity here i n figuring out how
to use that observation. The fact that we

254
00:16:42.998 --> 00:16:46.945
only need to solve a strictly easier
problem and that will enable the linear

255
00:16:46.957 --> 00:16:51.265
time implementation that I'm going to show
you next. So now, let's rewrite the high

256
00:16:51.277 --> 00:16:55.791
level recursive algorithm slightly to make
use of this observation that the closest

257
00:16:55.803 --> 00:17:00.027
split pair subroutine only has to operate
correctly in the regime of the unlucky

258
00:17:00.039 --> 00:17:04.164
case, when in fact, the closest split pair
is closer than the result of either

259
00:17:04.176 --> 00:17:08.206
recursive call. So I've erased the
previous steps 4 and 5, that, but we're

260
00:17:08.218 --> 00:17:12.310
going to rewrite them in a second. So,
before we invoke close split pair, what

261
00:17:12.322 --> 00:17:16.472
we're going to do is we're going to see
how well did our recursive calls do. That

262
00:17:16.484 --> 00:17:20.378
is, we're going to define a parameter
little delta, which is going to be the

263
00:17:20.390 --> 00:17:24.957
closest pair that we found or the distance
of the closest pair we found by either

264
00:17:24.969 --> 00:17:29.325
recursive call. So the minimum of the
distance between P1 and Q1, the closest

265
00:17:29.337 --> 00:17:34.078
pair that lies entirely on the left, and
P2Q2, the closest pair that lies entirely

266
00:17:34.090 --> 00:17:38.631
on the right. Now, we're going to pass
this delta information as a parameter into

267
00:17:38.643 --> 00:17:42.849
our closest split pair subroutine. We're
going to have to see why on earth that

268
00:17:42.861 --> 00:17:47.117
would be useful and I still owe you that
information, but, for now, we're just

269
00:17:47.129 --> 00:17:51.385
going to pass delta as a parameter for use
in the closest split pair. And then, as

270
00:17:51.397 --> 00:17:56.133
before we just do a comparison between the
three candidate closest pairs and return

271
00:17:56.145 --> 00:18:00.331
the best of the, of the trio. And so, just
so we're all clear on, on where things

272
00:18:00.343 --> 00:18:04.721
stand, so what remains is to describe the
implementation of closest split pair, and

273
00:18:04.733 --> 00:18:08.566
before I describe it, let me just be
crystal clear on what it is that we're

274
00:18:08.578 --> 00:18:13.778
going to demand of the subroutine. What do
we need to have a correct in o of n log n

275
00:18:13.216 --> 00:18:18.046
time closest pair algorithm. Well, as you
saw on the quiz, we want the running time

276
00:18:18.058 --> 00:18:22.475
to be o of n always, and for correctness,
what do we need? Again, we don't need it

277
00:18:22.487 --> 00:18:26.840
to always compute the closest split pair,
but we need it to compute the closest

278
00:18:26.852 --> 00:18:31.962
split pair in the events that there is a
split pair of distance strictly less than

279
00:18:31.974 --> 00:18:36.422
delta, strictly better than the outcome of
either recursive call. So now that we're

280
00:18:36.434 --> 00:18:40.874
clear on what we want, let's go ahead and
go through the pseudocode for this closest

281
00:18:40.886 --> 00:18:44.928
split pair subroutine. And I'm going to
tell you upfront, iIt's going to be fairly

282
00:18:44.940 --> 00:18:49.015
straightforward to figure out that the
subroutine runs in linear time, o of n

283
00:18:49.027 --> 00:18:52.527
time. The correctness requirement of
closest split pair will be highly

284
00:18:52.539 --> 00:18:56.148
non-obvious. In fact, after I show you
this pseudo you're not going to believe

285
00:18:56.160 --> 00:19:00.007
me. You're going to look at the pseudocode
and you'd be like, what are you talking

286
00:19:00.019 --> 00:19:03.512
about? But in the second video, on the
closest pair lecture, we will in fact show

287
00:19:03.524 --> 00:19:07.211
that this is a correct sub-routine. So,
how does it work? Well, let's look at a

288
00:19:07.223 --> 00:19:11.500
point set. So, the first thing we're going
to do is a filtering step. We're going to

289
00:19:11.512 --> 00:19:15.790
prune a bunch of the points away and so to
zoom in on a subset of the points. And the

290
00:19:15.612 --> 00:19:19.710
subset of the points we're going to look
at is those that lie in a vertical strip,

291
00:19:19.802 --> 00:19:24.030
which is roughly centered in the middle of
the point set. So, here's what I mean. By

292
00:19:24.042 --> 00:19:27.915
center dot, we're going to look at the
middle x coordinate. So, let x bar be the

293
00:19:27.927 --> 00:19:32.020
biggest x coordinate in the left half, so
that is in the sorted version of the

294
00:19:32.032 --> 00:19:37.362
points by x coordinate, we look at the n
over two smallest ex-coordinate. So, in

295
00:19:37.374 --> 00:19:42.971
this example where we have six points, all
this means is we draw, we imagine drawing

296
00:19:42.983 --> 00:19:48.630
a line between the third points, so that's
going to be x bar, the x coordinate of the

297
00:19:48.642 --> 00:19:52.807
third point from the left. Now, since
we're passed as input, a copy of the

298
00:19:52.819 --> 00:19:56.304
points sorted by x coordinate, we can
figure out what x bar is in constant time.

299
00:19:56.389 --> 00:20:00.068
Just by accessing the relevant entry of
the array, px. Now, the way we're going to

300
00:20:00.080 --> 00:20:03.371
use this parameter delta that we're
passed, so remember what delta is. So

301
00:20:03.383 --> 00:20:07.033
before we invoke the closest split pair
subroutine in the recursive algorithm, we

302
00:20:07.045 --> 00:20:10.699
make our two recursive calls, we find the
closest pair on the left, the closest pair

303
00:20:10.711 --> 00:20:14.169
on the right, and delta is whatever the
smaller of those two distances are. So

304
00:20:14.181 --> 00:20:17.899
delta is the parameter that controls
whether or not we actually care about the

305
00:20:17.911 --> 00:20:22.037
closest split pair or not, we care if and
only if there is a split pair at distance

306
00:20:22.049 --> 00:20:25.944
less than delta. So, how do we use delta?
Well, that's going to determine the width

307
00:20:25.956 --> 00:20:29.514
of our strip, so the strip's going to have
width 2 delta, and it's going to be

308
00:20:29.526 --> 00:20:33.034
centered around x. And the first thing
we're going to do is we're going to

309
00:20:33.046 --> 00:20:36.859
ignore, forevermore, points which do not
line in this vertical strip.

310
00:20:36.873 --> 00:20:40.954
So the rest of the algorithm will operate
only on the subset of p, the subset of the

311
00:20:40.966 --> 00:20:44.752
points that lie on the strip, and we're
going to keep track of them sorted by y

312
00:20:44.764 --> 00:20:48.791
coordinate. So the formal way to say that
they line the strip, is that they have x

313
00:20:48.803 --> 00:20:53.199
coordinate in the interval with lower
endpoint x bar minus delta and upper

314
00:20:53.449 --> 00:20:57.896
endpoint x bar plus delta. Now, how long
does it take to construct this set Sy

315
00:20:58.063 --> 00:21:02.945
sorted by y coordinate? Well fortunately,
we've been passed as input a sorted

316
00:21:02.957 --> 00:21:07.693
version of the points Py So to extract Sy
from Py, all we need to do is a simple

317
00:21:07.705 --> 00:21:12.712
linear scan through p y checking for each
point where its x coordinate is. So this

318
00:21:12.724 --> 00:21:17.564
can be done in linear time. Now, I haven't
yet shown you why it's useful to have this

319
00:21:17.576 --> 00:21:22.226
sorted set as y, but if you take it on
faith that it's useful to have the points

320
00:21:22.238 --> 00:21:25.974
in this vertical strip sorted by y
coordinate. You now see why it was useful

321
00:21:25.986 --> 00:21:30.017
that we did this merge sort all the way at
the beginning of the algorithm before we

322
00:21:30.029 --> 00:21:34.093
even underwent any recurssion. Remember,
what is our running time goal for closest

323
00:21:34.105 --> 00:21:38.195
split pair? We want this to run in linear
time, that means we cannot sort inside the

324
00:21:38.207 --> 00:21:41.948
closest split pair subroutine. That would
take too long. We want this to be in

325
00:21:41.960 --> 00:21:45.909
linear time. Fortunately, since we sorted
once and for all at the beginning of the

326
00:21:45.921 --> 00:21:50.030
closest pair algorithm, extracting sorted
sublists from those sorted lists of points

327
00:21:50.042 --> 00:21:54.495
can be done, done in linear time, which is
within our goals here. Now, it's the rest

328
00:21:54.507 --> 00:21:58.285
of t he subroutine where you're never
going to believe me that it does anything

329
00:21:58.297 --> 00:22:02.340
useful. So, I claim that essentially with
a linear scan through Sy, we're going to

330
00:22:02.352 --> 00:22:06.645
be able to identify the closest split pair
of points in the interesting, unlucky case

331
00:22:06.657 --> 00:22:11.190
where there is such a split pair with
distance less than delta. So here's what I

332
00:22:11.202 --> 00:22:15.320
mean by that linear scan through Sy. So as
we do the scan, we're, we're going to keep

333
00:22:15.332 --> 00:22:19.240
track of the closest pair of points of a
particular type that we've seen so far.

334
00:22:19.332 --> 00:22:23.135
So, let me introduce some variables to
keep track of the best candidate we've

335
00:22:23.147 --> 00:22:27.080
seen so far. There's going to be a vary,
variable best which will initialize to be

336
00:22:27.092 --> 00:22:30.955
delta. Remember, we're uninterested in
split pairs unless they have distance

337
00:22:30.967 --> 00:22:35.695
strictly less than delta. So, and then
we're going to keep track of the points

338
00:22:35.707 --> 00:22:40.847
themselves, so we'll initialize the best
pair to be null. Now, here is the linear

339
00:22:40.859 --> 00:22:46.218
scan. So we go through the points of Sy in
order y coordinate. Okay, well, not quite

340
00:22:46.230 --> 00:22:51.085
all the points of Sy. We stop at the
eighth to last point and you'll see why in

341
00:22:51.097 --> 00:22:58.523
a second. And then, for each position I of
the array Sy, we investigate the seven

342
00:22:58.535 --> 00:23:06.351
subsequent points of the same array Sy. So
for j going from one to seven, we look at

343
00:23:06.363 --> 00:23:12.837
the Ith, and I plus jth entry of Sy. So if
sy looks something like this array here,

344
00:23:12.945 --> 00:23:18.090
in any given point in this double for
loop, we're generally looking at an index

345
00:23:18.102 --> 00:23:23.940
I, a point in this, in this of the array,
and then some really quite nearby point in

346
00:23:23.952 --> 00:23:28.622
the array I plus j, because j here's going
to be at most seven. Okay? So we're

347
00:23:28.634 --> 00:23:32.221
constantly looking at pairs in this array,
but we're not looking at all pairs of all.

348
00:23:32.304 --> 00:23:35.519
We're only looking at pairs that are very
close to each other, within seven

349
00:23:35.531 --> 00:23:39.034
positions of each other. And what do we do
for each choice of i and j? Well, we just

350
00:23:39.046 --> 00:23:42.357
look at those points, we compute the
distance, we see if it's better than all

351
00:23:42.369 --> 00:23:45.801
of the pairs of points of this form that
we've looked at in the past and if it is

352
00:23:45.813 --> 00:23:49.788
better, then we remember it. So we just
remember the best, ie c losest pair of

353
00:23:49.800 --> 00:23:53.660
points, of this particular type for
choices of i and j of this form. So in

354
00:23:53.672 --> 00:23:57.598
more detail, if the distance between the
current pair of points of p and q is

355
00:23:57.610 --> 00:24:01.959
better than the best we've seen so far, we
reset the best pair of points to be equal

356
00:24:01.971 --> 00:24:05.864
to p and q, and we reset the best
distance, the closest distance seemed so

357
00:24:05.876 --> 00:24:10.402
far to be the distance between p and q and
that's it. Then, once this double for loop

358
00:24:10.414 --> 00:24:14.610
terminates, we just return it the best
pair. So one possible execution of closest

359
00:24:14.622 --> 00:24:18.750
split pair is that it never finds a pair
of points, p and q, at distance less than

360
00:24:18.762 --> 00:24:22.862
delta. In that case, this is going to
return null and then in the outer call. In

361
00:24:22.874 --> 00:24:26.944
the closet pair, obviously, you interpret
a null pair of points to have an infinite

362
00:24:26.956 --> 00:24:30.736
distance. So if you call closest split
pair, and it doesn't return any points,

363
00:24:30.826 --> 00:24:34.952
then the interpretation is that there's no
interesting split pair of points and you

364
00:24:34.964 --> 00:24:39.106
just return the better of the results of
the two recursive calls p1Q1 or P2Q2. Now,

365
00:24:39.196 --> 00:24:43.305
as far as the running time of the
subroutine, what happens here? Well, we do

366
00:24:43.317 --> 00:24:47.751
constant work just initializing the
variables. Then notice that the number of

367
00:24:47.763 --> 00:24:51.959
points in Sy, well in the worst case, you
have all of the points of P. So, it's

368
00:24:51.971 --> 00:24:55.983
going to be the most endpoints, and so,
you do a linear number of iterations in

369
00:24:55.995 --> 00:24:59.737
the outer for loop. But here is the key
point, in the inner for loop, right,

370
00:24:59.833 --> 00:25:03.895
normally double for loops give rise to
quadratic running time, but in this inner

371
00:25:03.907 --> 00:25:07.701
for loop we only look at a constant number
of other positions. We only look at seven

372
00:25:07.713 --> 00:25:11.237
other positions and for each of those
seven positions, we only do a constant

373
00:25:11.249 --> 00:25:14.970
number of work. Right? We just, we want to
compare distance and make a couple other

374
00:25:14.982 --> 00:25:18.653
comparisons, and reset some variables. So
for each of the linear number of outer

375
00:25:18.665 --> 00:25:22.313
iterations, we do a constant amount of
work, so that gives us a running time of o

376
00:25:22.325 --> 00:25:26.753
of n for this part of the algorithm. So as
I promised, analyzing the running time of

377
00:25:26.765 --> 00:25:30.409
this closest split pair subroutine was not
challenging. We just , in a

378
00:25:30.421 --> 00:25:34.489
straightforward way, looked at all the
operations. Again, because in the key

379
00:25:34.501 --> 00:25:38.758
linear scan, we only do constant work per
index, the overall running time is big O

380
00:25:38.770 --> 00:25:43.027
of n, just as we wanted. So this does mean
that our overall recursive algorithm will

381
00:25:43.039 --> 00:25:46.703
have running time o of n log n. What is
totally not obvious and perhaps even

382
00:25:46.715 --> 00:25:51.005
unbelievable, is that this subroutine
satifies the correctness requirements that

383
00:25:51.017 --> 00:25:54.889
we wanted. Remember, what we needed, we
needed that whenever we're in the unlucky

384
00:25:54.901 --> 00:25:58.900
case, whenever, in fact, the closest pair
of points in the whole point set is split,

385
00:25:58.989 --> 00:26:03.812
this subroutine better find it. So, but it
does, and that's being precise in the

386
00:26:03.824 --> 00:26:08.122
following correctness claim. So let me
rephrase the claim in terms of an

387
00:26:08.134 --> 00:26:12.828
arbitrary split pair, which has distance
less than delta, not necessarily the

388
00:26:12.840 --> 00:26:17.354
closest such pair. So suppose, there
exists, a p on the left, a point on the

389
00:26:17.366 --> 00:26:22.398
left side and a point on the right side so
that is a split pair and suppose the

390
00:26:22.410 --> 00:26:28.319
distance of this pair is less than Q. Now,
there may or may not be such a pair of

391
00:26:28.331 --> 00:26:33.847
points, PQ.. Don't forget what this
parameter delta means. What delta is, by

392
00:26:33.859 --> 00:26:39.643
definition, is the minimum of d of p1q1,
for p1q1 is the closest pair of points

393
00:26:39.655 --> 00:26:45.734
that lie entirely in the left half of the
point set Q and d of p2q2, or similarly,

394
00:26:45.746 --> 00:26:50.199
p2Q2 is the closest pair of points that
entirely on the right inside of R. So, if

395
00:26:50.211 --> 00:26:54.600
there's a split pair with distance less
than delta, this is exactly the unlucky

396
00:26:54.612 --> 00:26:59.134
case of the algorithm. This is exactly
where neither recursive call successfully

397
00:26:59.146 --> 00:27:03.596
identifies the closest pair of points,
instead that closest pair is a split pair.

398
00:27:03.694 --> 00:27:07.991
On the other hand, if we are in the lucky
case, then there will not be any split

399
00:27:08.003 --> 00:27:11.981
pairs with distance less than delta,
because the closest pair lies either all

400
00:27:11.993 --> 00:27:16.208
on the left or on the right, and it's not
split. But remember, we're interested in

401
00:27:16.220 --> 00:27:20.740
the case where there is a split pair that
has a distance less than delta where there

402
00:27:20.752 --> 00:27:24.743
is a split pair that is the closest pair.
So the claim has two parts. The first

403
00:27:24.755 --> 00:27:28.908
part, part A, says the following. It says
that if there's a split pair p and, and q

404
00:27:28.920 --> 00:27:34.439
of this type, then p and q are members of
Sy. And let me just sort of redraw the

405
00:27:34.451 --> 00:27:40.681
cartoon. So remember what Sy is. Sy is
that vertical strip. And again, the way we

406
00:27:40.693 --> 00:27:46.587
got that is we drew a line through a
median x coordinate and then we fattened

407
00:27:46.599 --> 00:27:52.543
it by delta on either side, and then, we
focused only on points that lie in the

408
00:27:52.555 --> 00:27:57.962
vertical strip. Now, notice our counts
split pair subroutine, if it ever returns

409
00:27:57.974 --> 00:28:02.323
a pair of points, it's going to return a
pair of points pq that belong to Sy.

410
00:28:02.427 --> 00:28:07.188
First, it filters down to Sy, then it does
a linear search through Sy. So if we want

411
00:28:07.188 --> 00:28:12.300
to believe that our subroutine identifies
best split pairs of points, then, in

412
00:28:12.312 --> 00:28:16.720
particular, such split pairs of points
better show up in Sy, they better survive

413
00:28:16.732 --> 00:28:21.190
the filtering step. So that's precisely
what part A of the claim is. Here's part B

414
00:28:21.202 --> 00:28:25.155
of the claim and this is the more
remarkable part of the claim, which is

415
00:28:25.167 --> 00:28:29.615
that p and q are almost next to each other
in this sorted array, Sy. So they're not

416
00:28:29.627 --> 00:28:34.055
necessarily adjacent, but they're very
close, they're within seven positions away

417
00:28:34.067 --> 00:28:38.190
from each other. So, this is really the
remarkable part of the algorithm. This is

418
00:28:38.202 --> 00:28:42.600
really what's surprising and what makes
the whole algorithm work. So, just to make

419
00:28:42.612 --> 00:28:46.575
sure that we're all clear on everything,
let's show that if we prove this claim,

420
00:28:46.667 --> 00:28:50.250
then we're done, then we have a correct
fast implementation of a closest pair

421
00:28:50.262 --> 00:28:54.360
algorithm. I certainly owe you the proof
of the claim, that's what the next video

422
00:28:54.372 --> 00:28:58.395
is going to be all about, but let's show
that if the claim is true, then, we're

423
00:28:58.668 --> 00:29:02.941
home-free. So if this claim is true, then
so is the following corollary, which I'll

424
00:29:02.953 --> 00:29:07.235
call corollaryl 1. So corollary 1 says, if
we're in the unlucky case that we

425
00:29:07.247 --> 00:29:11.386
discussed earlier, if we're in the case
where the closest point and the whole

426
00:29:11.398 --> 00:29:15.864
points of p does not lie both on the left,
does not lie both on the right, but rather

427
00:29:15.876 --> 00:29:20.112
has one point on the left and one on the
right but as it's a split pair, th en in

428
00:29:20.124 --> 00:29:25.162
fact, the count split pair subroutine will
correctly identify the closest split pair

429
00:29:24.901 --> 00:29:29.468
and therefore the closest pair overall.
Why is this true? Well what does count

430
00:29:29.480 --> 00:29:34.270
split pair do? Okay, so it has this double
for loop, and thereby, explicitly examines

431
00:29:34.282 --> 00:29:38.415
a bunch of pairs of points and it
remembers the closest pair of all of the

432
00:29:38.427 --> 00:29:42.870
pairs of points that it examines. What
does this, so what are the criteria that

433
00:29:42.882 --> 00:29:48.061
are necessary for count split pair to
examine a pair point? Well, first of all,

434
00:29:48.161 --> 00:29:52.631
the points p and q both have to survive
the filtering step and make it into the

435
00:29:52.643 --> 00:29:57.390
array Sy. Right? So count split pair only
searches over the array Sy. Secondly, it

436
00:29:57.402 --> 00:30:01.948
only searches over pairs of points that
are almost adjacent in Sy, that are only

437
00:30:01.960 --> 00:30:06.253
seven positions apart, but amongst pairs
of points that satisfy those two criteria,

438
00:30:06.346 --> 00:30:10.293
counts but pair will certainly compute the
closest such pair, right? It just

439
00:30:10.305 --> 00:30:14.196
explicitly remembers the best of them.
Now, what's the content of the claim?

440
00:30:14.289 --> 00:30:18.466
Well, the claim is guaranteeing that every
potentially interesting split pair of

441
00:30:18.478 --> 00:30:22.960
points and every split pair of points with
distance less than delta meets both of the

442
00:30:22.972 --> 00:30:26.403
criteria which are necessary to be
examined by the count split pair

443
00:30:26.403 --> 00:30:30.461
subroutine. So first of all, and this is
the content of part A, if you have an

444
00:30:30.473 --> 00:30:34.507
interesting split pair of points with
distance less than delta, then they'll

445
00:30:34.519 --> 00:30:38.920
both survive the filtering step. They'll
both make it into the array Sy., part A

446
00:30:38.932 --> 00:30:42.651
says that. Part B says they're almost
adjacent in Sy. So if you have an

447
00:30:42.663 --> 00:30:47.169
interesting split pair of points, meaning
it has distance less than delta, then they

448
00:30:47.181 --> 00:30:51.563
will, in fact, be at most seven positions
apart. Therefore, count split pair will

449
00:30:51.575 --> 00:30:55.849
examine all such split pairs, all split
pairs with distance less than delta, and

450
00:30:55.861 --> 00:31:00.268
just by construction, it will compute the
closest pair of all of them. So again, in

451
00:31:00.280 --> 00:31:04.646
the unlucky case where the best pair of
points is a split pair, then this claim

452
00:31:04.658 --> 00:31:08.619
guarantees that the count split pair will
compute the closest pair of points.

453
00:31:08.619 --> 00:31:12.984
Therefore, having h andled correctness, we
can just combine that with our earlier

454
00:31:12.996 --> 00:31:17.146
observations about running time and
corollary 2 just says, if we can prove the

455
00:31:17.158 --> 00:31:20.845
claim, then we have everything we wanted.
We have a correct O of n log n

456
00:31:20.857 --> 00:31:24.950
implementation for the closest pair of
points. So with further work and a lot

457
00:31:24.962 --> 00:31:29.062
more ingenuity, we've replicated the
guarantee that we got just by sorting for

458
00:31:29.074 --> 00:31:33.516
the one-dimensional case. Now again, these
corrollaries hold only if this claim is,

459
00:31:33.606 --> 00:31:37.567
in fact, true and I have given you no
justification for this claim. And even the

460
00:31:37.579 --> 00:31:41.300
statement of the claim, I think, is a
little bit shocking. So if I were you I

461
00:31:41.312 --> 00:31:45.112
would demand an explanation for why this
claim is true, and that's what I'm going

462
00:31:45.112 --> 00:31:46.514
to give you in the next video.